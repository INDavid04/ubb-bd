-------------------------LCD
-- COMMIT -> PERMANENTIZEAZA MODIFICARILE
-- ROLLBACK -> ANULEAZA MODIFICARILE PANA LA ULTIMUL COMMIT EXECUTAT
-- SAVEPOINT -> MARCHEAZA PUNCT INTERMEDIAR IN TRANZACTIE (SE POATE FACE ROLLBACK DOAR PANA LA PUNCTUL RESPECTIV)

-- PRIN MODIFICARI SE INTELEGE APLICAREA COMENZILOR: INSERT, UPDATE, DELETE
-- RULAREA UNEI COMENZI DE TIP LDD (CREATE, ALTER, DROP, TRUNCATE, RENAME) ADUCE IMPLICIT SI RULAREA UNUI COMMIT


    --EXEMPLU 1
-- TABEL_TEST ()
-- INSERT 1 => TABEL_TEST(1)
-- INSERT 2 => TABEL_TEST(1,2)
-- COMMIT => TABEL_TEST(1,2)
-- ROLLBACK => TABEL_TEST(1,2)
-- INSERT (3) => TABEL_TEST(1,2,3)
-- ROLLBACK => TABEL_TEST(1,2)

    --EXEMPLU 2
-- TABEL_TEST ()
-- INSERT 1 => TABEL_TEST(1)
-- INSERT 2 => TABEL_TEST(1,2)
-- CREATE (+COMMIT IMPLICIT) => TABEL_TEST(1,2)
-- INSERT (3) => TABEL_TEST(1,2,3)
-- SAVEPOINT P
-- INSERT (4) => TABEL_TEST(1,2,3,4)
-- ROLLBACK TO P => TABEL_TEST(1,2,3)

    --EXEMPLU 3
-- TABEL_TEST ()
-- INSERT 1 => TABEL_TEST(1)
-- INSERT 2 => TABEL_TEST(1,2)
-- CREATE (+COMMIT IMPLICIT) => TABEL_TEST(1,2)
-- INSERT (3) => TABEL_TEST(1,2,3)
-- SAVEPOINT P
-- INSERT (4) => TABEL_TEST(1,2,3,4)
-- ROLLBACK => TABEL_TEST(1,2)

    --EXEMPLU 4
-- TABEL_TEST ()
-- INSERT 1 => TABEL_TEST(1)
-- INSERT 2 => TABEL_TEST(1,2)
-- SAVEPOINT P
-- CREATE (+COMMIT IMPLICIT) => TABEL_TEST(1,2)
-- INSERT (3) => TABEL_TEST(1,2,3)
-- INSERT (4) => TABEL_TEST(1,2,3,4)
-- ROLLBACK TO P => EROARE COMPILARE

-------------------------LDD
    --CREARE TABELE

    -- METODA 1
-- MAI INTAI SE TRECE LISTA DE COLOANE, IAR PE URMA LISTA DE CONSTRANGERI LA NIVEL DE TABEL
-- PENTRU FIECARE COLOANA SE SPECIFICA NUMELE, TIPUL DE DATE SI EVENTUAL O VALOARE DEFAULT SAU O CONSTRANGERE LA NIVEL DE COLOANA
-- CONSTRANGERILE LA NIVEL DE COLOANA POT LUCRA DOAR CU COLOANA IN DREPTUL CAREIA ESTE TRECUTA
-- CONSTRANGERILE LA NIVEL DE TABEL POT LUCRA CU MAI MULTE COLOANE ALE TABELULUI
    -- (CUM AR FI PRIMARY KEY-URILE COMPUSE SAU CONSTRANGERILE DE TIP CHECK A CAROR CONDITIE LUCREAZA CU MAI MULTE COLAONE ALE TABELULUI)

CREATE TABLE ECHIPE (
    ID_ECHIPA NUMBER(10),
    NUME_ECHIPA VARCHAR2(10) NOT NULL, --CONSTRANGERE LA NIVEL DE COLOANA
    DATA_INFIINTARE DATE DEFAULT SYSDATE,
    VENIT_ANUAL NUMBER(10, 2),
    ABREVIERE_NUME VARCHAR2(3) CONSTRAINT VERIF_LG CHECK ( LENGTH(ABREVIERE_NUME) = 3), --CONSTRANGERE LA NIVEL DE COLOANA
    CONSTRAINT CHEIE_PRIMARA PRIMARY KEY (ID_ECHIPA), --CONSTRANGERE LA NIVEL DE TABEL
    CHECK ( VENIT_ANUAL > 100000 ) --CONSTRANGERE LA NIVEL DE TABEL
);
-- CONSTRANGERILE DE TIP NOT NULL SE PUN DOAR LA NIVEL DE COLOANA
-- CONSTRANGEREA DE LA LINIA 62 VA FI SALVATA CU NUMELE 'CHEIE_PRIMARA'
-- CONSTRANGEREA DE LA LINIA 63 VA FI SALVATA CU NUMELE 'SYS_...'
-- PENTRU A DA UN NUME PARTICULAR UNEI CONSTRANGERI SE FOLOSESTE SINTAXA 'CONSTRAINT <nume constrangere> <sintaxa specifica constrangerii respective>'

-- ATUNCI CAND SE FACE UN INSERT IMPLICIT, NESPECIFICANDU-SE O VALOARE PENTRU O COLOANA, ACEASTA VA PRIMI VALOAREA NULL,
    -- DAR DACA ESTE DEFINITA O VALOARE DEFAULT PE COLOANA RESPECTIVA, IN LOC DE NULL SE VA INSERA VALOAREA DEFAULT

CREATE TABLE JUCATORI (
    ID_JUCATOR NUMBER(10),
    NUME_JUCATOR VARCHAR2(10),
    NUMAR_TRICOU NUMBER(10),
    ECHIPA_ID NUMBER(10),
    CONSTRAINT CHEIE_PRIMARA_2 PRIMARY KEY (ID_JUCATOR),
    CONSTRAINT NR_TRICOU_UNIC UNIQUE (NUMAR_TRICOU),
    CONSTRAINT FK_JUC_ECH FOREIGN KEY (ECHIPA_ID)
            REFERENCES ECHIPE(ID_ECHIPA)
);

-- ATENTIE! CONSTRANGERILE TREBUIE SA AIBE NUME UNIC LA NIVELUL SERVERULUI, NU AL TABELULUI
    -- DACA IN 'ECHIPE' AM O CONSTRANGERE CU NUMELE 'CHEIE_PRIMARA', NU POT AVEA SI IN ALTE TABELE CONSTRANGERI CU ACEASTA DENUMIRE
-- IN CAZUL CONSTRANGERILOR DE TIP FOREIGN KEY SE POATE FACE REFERINTA DOAR CATRE COLOANE CARE IN TABELUL REFERENTIAT AU CONSTRANGERE DE TIP PRIMARY KEY SAU UNIQUE

--METODA 2
CREATE TABLE COPIE_EMPLOYEES AS
    SELECT EMPLOYEE_ID, SALARY * 12
    FROM EMPLOYEES; -- SE VA CREA UN TABEL CARE VA AVEA STRUCTURA DETERMINATA DE CAMPURILE DIN CLAUZA SELECT SI VA CONTINE INREGISTRARILE SUBCERERII SPECIFICATE (SELECT)
-- ATUNCI CAND SE CREEAZA UN TABEL CU ACEASTA METODA, SE VOR PRELUA DIN TABELUL/TABELELE DIN CLAUZA FROM DOAR CONSTRANGERILE DE TIP NOT NULL


    -- MODIFICARE LA NIVEL STRUCTURAL A TABELELOR (LA NIVEL DE COLOANE SAU CONSTRANGERI)
--ALTER
    -- ADAUGARE COLOANE
ALTER TABLE JUCATORI
ADD NR_GOLURI NUMBER(10) DEFAULT 0;

    -- MODIFICARE COLOANA (TIP DE DATE, DIMENSIUNE, VALOARE DEFAULT)
ALTER TABLE JUCATORI
MODIFY NR_GOLURI VARCHAR2(10); --DOAR DACA PE COLOANA RESPECTIVA NU EXISTA VALORI NENULE SAU IN TABEL NU EXISTA INREGISTRARI

ALTER TABLE JUCATORI
MODIFY NR_GOLURI NUMBER(5); --DOAR DACA PE COLOANA RESPECTIVA NU EXISTA VALORI NENULE SAU IN TABEL NU EXISTA INREGISTRARI

ALTER TABLE JUCATORI
MODIFY NR_GOLURI VARCHAR2(5); --DOAR DACA PE COLOANA RESPECTIVA NU EXISTA VALORI NENULE SAU IN TABEL NU EXISTA INREGISTRARI SAU SIRURILE DEJA EXISTENTE RESPECTA NOUA DIMENSIUNE

ALTER TABLE JUCATORI
MODIFY NR_GOLURI VARCHAR2(15); --CRESTEREA DIMENSIUNII SE POATE FACE ORICAND

    -- STERGERE COLOANE
ALTER TABLE JUCATORI
DROP COLUMN NR_GOLURI;

    -- ADAUGARE CONSTRANGERI
ALTER TABLE JUCATORI
ADD (
        CONSTRAINT VERIF_NR_TRICOU CHECK ( NUMAR_TRICOU >= 1 AND NUMAR_TRICOU <= 99 ),
        CONSTRAINT LG_NUME CHECK ( LENGTH(NUME_JUCATOR) >= 5 )
    );

    -- STERGERE CONSTRANGERI
ALTER TABLE JUCATORI
DROP CONSTRAINT LG_NUME;

    -- DEZACTIVARE CONSTRANGERI
-- ATENTIE! ATUNCI CAND DEZACTIVATI O CONSTRANGERE SI MODIFICATI DATELE TABELULUI, IN MOMENTUL IN CARE O REACTIVATI ESTE NECESAR CA DATELE MODIFICATE SA RESPECTE CONDITIA IMPUSA DE CONSTRANGERE, IN CAZ CONTRAR, NU SE VA PUTEA REACTIVA
ALTER TABLE JUCATORI
DISABLE CONSTRAINT VERIF_NR_TRICOU;

ALTER TABLE JUCATORI
ENABLE CONSTRAINT VERIF_NR_TRICOU;

    -- STERGEREA TABELELOR
--DROP
-- ATENTIE! ATUNCI CAND STERGETI UN TABEL, TREBUIE SA FIE MAI INTAI STERSE SI CONSTRANGERILE DE TIP FOREIGN KEY CARE REFERENTIAZA CATRE TABELUL IN CAUZA (IN ACEST CAZ, CONSTRANGEREA DE TIP FK DIN JUCATORI)
DROP TABLE ECHIPE;
